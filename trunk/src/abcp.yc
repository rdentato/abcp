#include "abcp_h"


/*
** = Naming convention
** 
**  abc_xxx  Internal function, not to be used from 
**           the host application
**
**  abc_SXxx Dealing with ABCp state
**
**  abcXxx   Exposed function
*/

#define abc_atoi(_s) ((_s) == NULL? 0, atoi(_s))

#define abc_setToken(_s,_t,_f,_l) ((s)->token=_t, (s)->tokstart=_f, (s)->toklen=_l)
#define abc_ST0(_s,_t) abc_setToken(_s,_t,abc_START(_s,0),abc_LEN(_s,0))

#define abc_NL(_s)        (abc_ST0(T_NEWLINE),  abcNewLine(_s), 0)
#define abc_Emptyline(_s) (abc_ST0(T_EMPTYLINE),abcEmptyLine(_s), 0)
#define abc_Space(_s)     (abc_ST0(T_SPACE),    abcSpace(_s,abc_START(_s,0),abc_LEN(_s,0)), 0)
#define abc_Text(_s)      (abc_ST0(T_TEXT),     abcText(_s,abc_START(_s,1),abc_LEN(_s,1)), 0)
#define abc_Overlay(_s)   (abc_ST0(T_OVERLAY),  abcOverlay(_s,abc_LEN(_s,1),abc_START(_s,2)), 0)
#define abc_Grace(_s)     (abc_ST0(T_GRACE),    abcGrace(_s,abc_LEN(_s,1)), 0)
#define abc_GraceEnd(_s)  (abc_ST0(T_GRACEEND), abcGrace(_s,-1), 0)
#define abc_Tuplet(_s)    (abc_ST0(T_TUPLET),   abcTuplet(_s,abc_atoi(abc_START(_s,1)),\
                                                             abc_atoi(abc_START(_s,2)),\
                                                             abc_atoi(abc_START(_s,3))), 0)
#define abc_Spacer(_s)    (abc_ST0(T_SPACER),   abcSpacer(_s,abc_atoi(abc_START(_s,1),abc_START(_s,2)), 0)

#define abc_Broken(_s)    (abc_ST0(T_BROKEN),   abcBroken(_s,*abc_START(_s,0),abc_LEN(_s,0)), 0)

#define abc_Tie(_s)       (abc_ST0(T_TIE),      abcTie(_s,abc_START(_s,1),abc_START(_s,2)), 0)
#define abc_Slur(_s)      (abc_ST0(T_SLUR),     abcSlur(_s,abc_START(_s,1),abc_START(_s,2)), 0)
#define abc_SlurEnd(_s)   (abc_ST0(T_SLUREND),  abcSlurEnd(_s), 0)

#define abc_Ending(_s)    (abc_ST0(T_ENDING),   abcEnding(_s,abc_atoi(abc_START(_s,1))), 0)

#define abc_Chord(_s)     (abc_ST0(T_CHORD),    abcChord(_s), 0)
#define abc_ChordEnd(_s)  (abc_ST0(T_CHORDEND), abcChordEnd(_s), 0)
#define abc_Bar(_s)       (abc_ST0(T_BAR),      abcBar(_s,abc_START(s,1),abc_LEN(s,1)), 0)
#define abc_Continue(_s)  (abc_ST0(T_CONTINUE), abcContinue(_s,abc_START(s,1),abc_LEN(s,1)), 0)

#define abc_Annotation(s) (abc_ST0(T_ANNOTATION), abcAnnotation(_s,abc_START(s,0),abc_LEN(s,0)), 0)

/* = Comments
*/

static short abc_Comment(abcScanner *s)
{
  abc_ST0(T_COMMENT);
  YYSWITCH(s->stream) {
    "[^\c]+": s->toklen += abc_LEN(s,0);
  }
  abcComment(s,abc_START(s,0),abc_LEN(s,0));
  return 0;
}

/* = Rests
*/
static short abc_Rest(abcScanner *s)
{
  unsigned short num=1,den=1;
  
  abc_ST0(T_REST);
  if (abc_LEN(s,1) >0)  num = atoi(abc_START(s,1));
  if (abc_LEN(s,3) >0) den = atoi(abc_START(s,3));
  if (den == 1 && abc_LEN(s,2) >0) den = 1 << abc_LEN(s,2);
  abcRest(s,*abc_START(s,0),num,den)
  return 0;
}


/* = Guitar chords
*/
static short abc_GChord(abcScanner *s)
{
  char *root[2];
  char *acc[2];
  char *bass[2];
  char *type[2];
  
  unsigned short typelen[2];
  unsigned char cur=0;

  abc_ST0(T_GCHORD);

  YYSTATE(chord) {
    YYSWITCH(s->stream) {
      "[A-G]([b#]?)\Y"  : root[cur] = abc_START(s,0);
                          acc[cur]  = abc_START(s,1);
    }
  }
  
  type[cur]    = YYCURSOR(s->stream)
  typelen[cur] = 0;
  
  YYSTATE(type) {
    YYSWITCH(s->stream) {
      YYEOF       : 
      YYEOL       : YYGOTO(gchordend);
      
      "/([A-G])"  : bass[cur] = abc_START(s,1);
                    YYGOTO(prtchord);
      "\|\([A-G]" : YYGOTO(prtchord);
      
      "\""        : YYGOTO(gchordend);
      default     : typelen[cur]++;
                    YYGOTO(type);
  
    }         
  }
  
  
  YYSWITCH(s->stream) {
    "(.*)\|/([A-G])"  :  type[cur]=
    "(.*)\(\|[A-G]" :
    "(.*) root[cur] = abc_START(s,0);
                        acc[cur]  = abc_START(s,1);
  }
  
  
    char *root[0]=abc_START(s,0);
  char *acc[0]=abc_START(s,1);
  
  abc_ST0(T_GCORD);
  
  YYSWITCH(s->stream) {
    "([^\s]*)/([A-G])\Y\""  :
    "(.*)\Y\""              : s->toklen += abc_LEN(s,0);
    default                   : return -1;
  }
  abcGChord(s,root,acc,abc_START(s,1),abc_LEN(s,1),abc_START(s,2));
  return 0; 
}

/* = States
**
*/

static short abc_SLimbo(abcScanner *s) 
{
  YYSWITCH(s->stream) {
    YYEOF        : return -1;
    "^(\Y)(\a):" : s->nextstate = S_TUNE;
                   return abc_Field(s);
    "^\Y%%\Y"    : return abc_XField(s);
    "^\Y%"       : return abc_Comment(s);    /**/
    "^\Y$"       : return abc_Emptyline(s);  /**/
    YYEOL        : return abc_NL(s);         /**/
    "^(.*)$"     : return abc_Text(s);       /**/
  } 
  return -1;
}

static short abc_STune(abcScanner *s)
{
  YYSTATE(tune) {
    YYSWITCH(s->stream) {
      YYEOF : return -1;
      
      "([[\x02\n])\Y(\a):"    : return abc_Field(s);
      "^\Y%%\Y"               : return abc_XField(s);
      "^\Y$"                  : s->nextstate = S_LIMBO;
                                return abc_Emptyline(s);  /**/
      YYSOL                   : YYGOTO(tune);
      YYEOL                   : return abc_NL(s);         /**/
      "`+"                    :
      "\y\Y"                  : return abc_Space(s);      /**/
      "(&+)([()]?)"           : return abc_Overlay(s);    /**/
      "\{(/?)"                : return abc_Grace(s);      /**/
      "}"                     : return abc_GraceEnd(s);   /**/
      "(\(?([_^=]*)(\d*)(/*)(\d*)([',]?)\)?)([A-Ga-g])":
                                return abc_Note(s);
      "Z(\d*)"                :
      "[xz](\d*)(/*)(\d*)"    : return abc_Rest(s);       /**/ 
      "y(\d*)([impx]?)"       : return abc_Spacer(s);     /**/ 
      "\((\d+):?(\d*):?(\d*)" : return abc_Tuplet(s);     /**/
      "<+"                    :
      ">+"                    : return abc_Broken(s);     /**/
      "(\.?)([(\-])([',]?)"   : if (*abc_START(s,1) == '(')
                                  return abc_Slur(s);     /**/
                                else
                                  return abc_Tie(s);      /**/
      "\)"                    : return abc_SlurEnd(s);    /**/
      "\[?(\d+)"              : return abc_Ending(s);     /**/
      "\[\|[^]|:]"            : return abc_Chord(s);      /**/
      "\]\|[^]|:]"            : return abc_ChordEnd(s);   /**/
      "(\.?[]:|[]*[]:|])"     : return abc_Bar(s);        /**/
    }
    
    return abc_SSym(s)
  }
}

static short abc_SSym(abcScanner *s)
{
    YYSWITCH(s->stream) {
      YYEOF                 : return -1;
      "\n"                  :
      "\\\y+%\Y(.*)$"       : return abc_Continue(s);         /**/
      "\"\|[A-G]"           : return abc_GChord(s);           /**/
      "\Q"                  : return abc_Annotation(s);       /**/      
      "\Y%"                 : return abc_Comment(s);          /**/    
      "([~.H-Wh-w])"        :
      "!([^\c\s!]+)!"       :
      "\+([^\c\s+]+)\+"     : return abc_Decoration(s);
    }
    return -1;
}
                                
static short abc_SSymbols(abcScanner *s)
{
  YYSTATE(symbol) {
    YYSWITCH(s->stream) {
      YYEOF             : return -1;
      YYSOL             : YYGOTO(symbol);
      YYEOL             : s->nextstate = S_TUNE; return abc_NL(s);
      "\Y(|)\Y"         : return abc_Bar(s);        /**/
      "\Y\*\Y"          : return abc_Blank(s);
      "\Y(\d+)[.):]"    : return abc_Verse(s);
    }
  }
  return abcSSym(s);
}

static short abc_SWords(abcScanner *s)
{
  YYSTATE(words) {
    YYSWITCH(s->stream) {
      YYEOF             : return -1;
      YYSOL             : YYGOTO(words);
      YYEOL             : s->nextstate = S_TUNE;
                          return abc_NL(s);
      
      "\n"              :
      "\\\y\Y%\Y(.*)$"  : return abc_Continue(s);  /**/
      "\Y%"             : return abc_Comment(s);   /**/   
      
      "\Y(|)\Y"         : return abc_Bar(s);       /**/
      "\Y\*\Y"          : return abc_Blank(s);
      "\Y(\d+)[.):]"    : return abc_Verse(s);
      
      "([^\c\0-]+)-*"   : return abc_Syllable(s);
      "_"               : return abc_SyllableHold(s);
      "\y\Y"            : return abc_Space(s);
      "."               : YYGOTO(words);
    }
  }
  return -1;
}

unsigned short abcNextToken(abcScanner *s)
{
  short res=0;
  
  /* Change to a new state if required */
  switch (s->nextstate) {
    case S_NONE   : break; 
    
    case S_EATSOL : 
            YYSWITCH(abcStream(s)) {
              YYSOL: break;
            };
            break;
                    
    case S_INCLUDE: abcInclude(s);
                    break;
                    
    default       : s->state = s->nextstate;
  }
  s->nextstate = S_NONE;
  s->token    = T_NONE;
  s->toklen   = 0;
  s->tokstart = NULL;
    
  switch (s->state) {
    case S_EOF           : abc_setToken(s,T_EOF,NULL,0); break;
    case S_LIMBO         : res = abc_SLimbo(s);         break;
    case S_TUNE          : res = abc_STune(s);          break;
    case S_FIELD   | 'w' : res = abc_SWords(s);         break;
    case S_FIELD   | 's' : res = abc_SSymbols(s);       break;
  } 

  if (res == -1) {
    YYSWITCH(abcStream(s)) {
      YYEOF : if (abc_delstream(s) == NULL) {
                s->state    = S_EOF;
                abc_setToken(s,T_EOF,NULL,0);
              }
              else
                abc_setToken(s,T_INCLUDE_EOF,NULL,0);
              break;
              
      "."   : abc_setToken(s,T_UNKNOWN,abc_START(s,0),1);
              break;
    }
  }
  return s->token;
}






