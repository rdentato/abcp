/*
**  (C) by Remo Dentato (rdentato@gmail.com)
**
** This software is distributed under the terms of the BSD license:
**   http://creativecommons.org/licenses/BSD/
**   http://opensource.org/licenses/bsd-license.php
*/

#include "abcp_priv.h"

/*
  1 (K or V)
  2 the field line
*/

#define MAXPARMS 20
static short parms[MAXPARMS];

static char exp[8];

#define MAXTABSTRINGS 20
static short tablature[MAXTABSTRINGS];

#define setstring(s,b,f,t) ((s)->tok_str[b][0]=f,(s)->tok_str[b][1]=t)

static void settablature(char *start, char *end)
{
  int k;
}

static void abc_clef(abcScanner *scn, char *start, char *end)
{
  _dbgmsg("XXXX\n");
  while (start < end) {
    switch pmx(start) {

      case "&k" :
      case "&e\\&B[]" :
        break;

      case "clef&K=&K(<+=A-Za-z&-><*d><?$tab>)":
        setstring(scn,ABC_Clef,pmx(Start,1),pmx(End,1));
        break;

      case "tab&K=&K(<+=^_A-Ga-g,'>)" :
        settablature(pmx(Start,1),pmx(End,1));
        break;

      case "n<?=a>m<?=e>&K=&K&e\\(&q)" :
        setstring(scn,ABC_Name,pmx(Start,1)+1,pmx(End,1)-1);
        break;

      case "s<?$ub$hort>n<?=a>m<?=e>&K=&K&e\\(&q)" :
        setstring(scn,ABC_ShortName,pmx(Start,1)+1,pmx(End,1)-1);
        break;

      case "stem&K=&K&i(<$up$u$down$d>)" :
        parms[ABC_Stems] = tolower(*pmx(Start,1));
        break;

      case "gstem&K=&K&i(<$up$u$down$d>)" :
        parms[ABC_Gstems] = tolower(*pmx(Start,1));
        break;

      case "sp<?=a>c<?=e>&K=&K(&d)" :
        parms[ABC_Space] = atoi(pmx(Start,1));
        break;

      case "st<?=a>v<?$es>&K=&K(&d)" :
        parms[ABC_Staves] = atoi(pmx(Start,1));
        break;

      case "br<?=a>c<?$es>&K=&K(&d)" :
        parms[ABC_Brace] = atoi(pmx(Start,1));
        break;

      case "br<?$ac>k<?$et>o(<$n$ff)" :
        parms[ABC_Bracket] = (*pmx(Start,1) == 'n')? 256 : -1;
        break;

      case "br<?$ac>k<?$et><?=s>&K=&K(&d)" :
        parms[ABC_Bracket] = atoi(pmx(Start,1));
        break;

      case "program&K(&d)&K(&D)" :
        if (abcTokenLen(scn,1) == 0) {
          parms[ABC_Program] = atoi(pmx(Start,1));
        } else {
          parms[ABC_ProgramChannel] = atoi(pmx(Start,1));
          parms[ABC_Program] = atoi(pmx(Start,2));
        }
        break;

       case "merge" :
         parms[ABC_Merge] = 'y';
         break;

       case "mute" :
         parms[ABC_Mute] = 'y';
         break;

       case "tune&K(&d)" :
         parms[ABC_Tune] = atoi(pmx(Start,1));
         break;

       case "pan&K(&d)" :
         parms[ABC_Pan] = atoi(pmx(Start,1));
         break;

       case "volume&K(&d)" :
         parms[ABC_Volume] = atoi(pmx(Start,1));
         break;

       case "longbaro(<$n$ff>)" :
         parms[ABC_Longbar] = *pmx(Start,1) == 'n'? 'y' : 'n';
         break;

      case "gch<?$ords>&K=&K(<=w>)<*S>" :
        switch (*pmx(Start,1)) {
          case '0': case 'n' : case 'N' :
            parms[ABC_Gchord] = 'n'; break;
          case '1': case 'y' : case 'Y' :
            parms[ABC_Gchord] = 'y'; break;
        }
        break;

      case "t<?$ranspose>&K=&K(&d)" :
        parms[ABC_Transpose] = atoi(pmx(Start,1));
        break;

      case "o<?$ctave>&K=&K(&d)" :
        parms[ABC_Octave] = atoi(pmx(Start,1));
        break;

      case "s<$tafflines>&K=&K(&d)" :
        parms[ABC_Stafflines] = atoi(pmx(Start,1));
        break;

      case "m<$iddle>&K=&K(<=A-Ga-g>)" :
        parms[ABC_Middle] = *pmx(Start,1);
        break;

      case "<=+&-><d><?d>" :
        parms[ABC_Transpose] = atoi(pmx(Start,0));
        break;

      case "(<$up$down$u%d>)" :
        parms[ABC_Stems] = tolower(*pmx(Start,1));
        break;

      case "(<+=A-Za-z&-><*d><?$tab>)" :
        setstring(scn,ABC_Clef,pmx(Start,1),pmx(End,1));
        break;

      case "<.>" :
        break;

    }
  }
}

#define returnifnot(s,c,r)  do {\
                              if ((abcToken(s) != T_FIELD && \
                                   abcToken(scn) != T_INFIELD) || \
                                  (*abcTokenStart(scn,1) != c)) \
                                return r;\
                              if (!abcTestFlag(scn,ABC_F_CLEFSCANNED)) {\
                                if (kv == 'K') abc_key(scn);\
                                else if (kv == 'V') abc_voice(scn);\
                                else return r;\
                              }\
                            } while(utlZero)

static void abc_key(abcScanner *scn)
{
  char *p, *q;
  int k;

  p = abcTokenStart(scn,2);
  q = abcTokenEnd(scn,2);

  if (p == NULL || p >= q || abcTestFlag(scn,ABC_F_CLEFSCANNED)) return;

  abcSetFlag(scn,ABC_F_CLEFSCANNED);
  for (k = 0; k<MAXTABSTRINGS; k++) tablature[k] = 0;
  for (k = 0; k<8; k++) exp[k] = ' ';
  exp[7] = '\0';
  for (k = 0; k<MAXPARMS; k++) parms[k] = 0;

  switch pmx(p) {
    case "(<=A-Ga-g><?=&#b>)&K" :
    case "(<$none$hp$Hp$>)&K" :
      setstring(scn,ABC_Tonic,pmx(Start,1),pmx(End,1));
      break;
  }

  switch pmx(p) {
    case "&imix<?$olydian>&K"  : parms[ABC_Mode] = 'X';   break;
    case "&imaj<?$or>&K"       : parms[ABC_Mode] = 'M';   break;
    case "&imin<?$or>&K"       : parms[ABC_Mode] = 'N';   break;
    case "&idor<?$ian>&K"      : parms[ABC_Mode] = 'D';   break;
    case "&iphr<?$ygian>&K"    : parms[ABC_Mode] = 'P';   break;
    case "&ilyd<?$ian>&K"      : parms[ABC_Mode] = 'Y';   break;
    case "&iloc<?$rian>&K"     : parms[ABC_Mode] = 'O';   break;
    case "&iion<?$ian>&K"      : parms[ABC_Mode] = 'I';   break;
    case "&iaeo<?$lian>&K"     : parms[ABC_Mode] = 'A';   break;
    case "M&K"                 : parms[ABC_Mode] = 'M';   break;
    case "m&K"                 : parms[ABC_Mode] = 'N';   break;
  }

  switch pmx(p) {
    case "&iexp&K<?==>&K" :  break;
  }

  k = 1;
  while (k) {
    switch pmx(p) {
      case "(<+=^_=>)(<=A-Ga-g>)&K" :
        k = (tolower(*pmx(Start,2)) + 7 -'c') % 7 ;
        switch (*pmx(Start,1)) {
          case '=' : exp[k] = 'n';  break;
          case '_' : exp[k] = (pmx(Len,1) > 1) ? 'F' : 'f';  break;
          case '^' : exp[k] = (pmx(Len,1) > 1) ? 'S' : 's';  break;
        }
        k = 1;
        break;

      default: k = 0;
    }
  }

  abc_clef(scn,p,q);
}

static void abc_voice(abcScanner *scn)
{
  char *p, *q;
  int k;

  p = abcTokenStart(scn,2);
  q = abcTokenEnd(scn,2);

  if (p == NULL || p >= q || abcTestFlag(scn,ABC_F_CLEFSCANNED)) return;

  abcSetFlag(scn,ABC_F_CLEFSCANNED);
  for (k = 0; k<MAXTABSTRINGS; k++) tablature[k] = 0;
  for (k = 0; k<8; k++) exp[k] = ' ';
  exp[7] = '\0';
  for (k = 0; k<MAXPARMS; k++) parms[k] = 0;

  switch pmx(p) {
    case "(<+S>)&K" :
      setstring(scn,ABC_VoiceId,pmx(Start,1),pmx(End,1));
      break;
  }

  switch pmx(p) {
    case "(&q)&K" :
      setstring(scn,ABC_Name,pmx(Start,1)+1,pmx(End,1)-1);
      break;
  }

  abc_clef(scn,p,q);
}

char *abcKVStringStart(abcScanner *scn,int str, char kv)
{
  returnifnot(scn,kv,utlEmptyString);
  return abcTokenStart(scn,str);
}

int abcKVStringLen(abcScanner *scn,int str,char kv)
{
  returnifnot(scn,kv,0);
  return abcTokenLen(scn,str);
}

short abcKVParm(abcScanner *scn,int p,char kv)
{
  returnifnot(scn,kv,0);
  return parms[p];
}

short abcKVTranspose(abcScanner *scn,char kv)
{
  returnifnot(scn,kv,0);
  return parms[ABC_Transpose]+parms[ABC_Octave]*12;
}

char *abcKVExp(abcScanner *scn,char kv)
{
  returnifnot(scn,kv,utlEmptyString);
  return exp;
}

